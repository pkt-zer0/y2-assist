<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Y2 assistant</title>
    <!--suppress CssUnusedSymbol -->
    <style>
        :root {
            --text-color: black;
            --text-bg: white;
            --button-bg: #f0f0f0;
            --button-bg-on: #333;
            --button-fg-on: white;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --text-color: white;
                --text-bg: #333;
                --button-bg: #101010;
                --button-bg-on: #888;
                --button-fg-on: black;
            }
            a:link {
                color: #3391ff;
            }
            a:visited {
                color: #a240ff;
            }
            .speed.reversal {
                background: black !important;
            }
        }

        html {
            background: var(--text-bg);
            color: var(--text-color);
            font-size: 4vw;
            user-select: none;
        }
        html, body {
            padding: 0;
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        #main, .screen {
            height: 100%;
        }
        * {
            box-sizing: border-box;
            touch-action: manipulation;
        }
        .screen.main, .screen.picker, .screen.about {
            display: flex;
            flex-direction: column;
        }
        .screen.picker {
            overflow-y: auto;
        }
        .screen.about, .screen.help {
            button {
                margin: 0;
                font-size: 1.5rem;
                height: 3rem;
            }
        }
        .screen.about {
            align-items: center;
            font-size: 1.5rem;
            text-align: center;

        }
        .screen.help {
            display: flex;
            flex-direction: column;

            .content {
                overflow-y: auto;
            }
            article {
                border-bottom: 0.0625rem solid black;
                padding: 1rem;

                h4 {
                    margin: 0 0 0.5rem;
                }
                p {
                    margin: 0;
                }
                code {
                    font-weight: normal;
                    float: right;
                }
            }
        }
        .controls, .toggles, .header {
            display: flex;
            width: 100%;
            font-size: 1.5rem;
            justify-content: space-between;
            flex-shrink: 0;
        }
        .controls { height: 3rem; }
        .toggles  { height: 2rem; }
        button {
            background: var(--button-bg);
            color: var(--text-color);

            font-size: 1rem;
            flex-basis: 0;
            flex-grow: 1;
            margin: 0 0.5rem;
            border-width: 0.0625rem;
        }
        button.large {
            flex-grow: 2;
        }
        button.fixed {
            flex-grow: 0;
        }
        button.on {
            background: var(--button-bg-on);
            color: var(--button-fg-on);
        }
        .move {
            position: relative;
            width: 75vw;
            aspect-ratio: 1;
            font-size: 3rem;
            margin: auto;
        }
        .damage, .blockDamage, .speed, .adjust, .flags, .height, .level {
            display: flex;
            position: absolute;
            align-items: center;
            justify-content: center;
        }
        .description {
            position: absolute;
            left: 5%;
            font-size: 0.8em;
        }
        .damage {
            width: 50%;
            height: 50%;
            left: 20%;
            top: 20%;
            color: white;
            border-radius: 50%;
            overflow: hidden;
        }
        .damage.block {
            border-radius: 10% 10% 50% 50%;
        }
        .damage.projectile {
            border-radius: 20% 50% 50% 20%;
        }
        .blockDamage {
            background: lightblue;
            color: black;
            width : 20%;
            height: 20%;
            left  : 58%;
            top   : 58%;
            text-align: center;
            border-radius: 10% 10% 50% 50%;
        }
        .blockGap {
            position: absolute;
            background: gray;
            width: 100%;
            height: 50%;
        }
        .speed {
            background: palegoldenrod;
            color: black;
            border-color: black;

            border-width: 0.0625rem;
            border-style: solid;
            top: 10%;
            left: 60%;
            width: 20%;
            height: 20%;
            border-radius: 50%;
        }
        .speed.reversal {
            background: #333;
            color: palegoldenrod;
            border-color: darkgoldenrod;
        }

        .adjust {
            background: sandybrown;
            color: black;
            width : 20%;
            height: 30%;
            left  : 80%;
            top   : 30%;
        }
        .level {
            width: 20%;
            height: 20%;
            top: 50%;
            left: 20%;
            border-radius: 25%;
            font-size: 0.80em;
            color: black;
        }
        .flags {
            top: 80%;
            width: 90%;
            font-size: 0.8em;
            text-align: center;
        }
        .height {
            background: #800;
            width: 10%;
            height: 10%;
            left: 10%;
            border-radius: 50%;
        }
    </style>
    
</head>
<body>
<div id="main"></div>

        <script type="application/javascript">
            (function () {
  'use strict';

  var MoveType;
  (function (MoveType) {
      MoveType[MoveType["Dodge"] = 0] = "Dodge";
      MoveType[MoveType["Throw"] = 1] = "Throw";
      // Attacks
      MoveType[MoveType["Strike"] = 2] = "Strike";
      MoveType[MoveType["Projectile"] = 3] = "Projectile";
      // Blocks
      MoveType[MoveType["BlockLow"] = 4] = "BlockLow";
      MoveType[MoveType["BlockHigh"] = 5] = "BlockHigh";
      MoveType[MoveType["BlockFull"] = 6] = "BlockFull";
  })(MoveType || (MoveType = {}));
  var StrikeHeight;
  (function (StrikeHeight) {
      StrikeHeight[StrikeHeight["Low"] = 0] = "Low";
      StrikeHeight[StrikeHeight["Mid"] = 1] = "Mid";
      StrikeHeight[StrikeHeight["High"] = 2] = "High";
  })(StrikeHeight || (StrikeHeight = {}));
  var ArmorType;
  (function (ArmorType) {
      ArmorType[ArmorType["None"] = 0] = "None";
      ArmorType[ArmorType["Light"] = 1] = "Light";
      ArmorType[ArmorType["Medium"] = 2] = "Medium";
      ArmorType[ArmorType["Heavy"] = 3] = "Heavy";
  })(ArmorType || (ArmorType = {}));
  // Built-in flags
  const FLAG_DEFS = {
      unsafe: { icon: `⚠`, desc: `Unsafe on block` },
      edge: { icon: `⊕`, desc: `Edge on block or hit` },
      knockdown: { icon: `KD`, desc: `Knockdown on hit` },
      recur: { icon: `RECUR`, desc: `+1 handsize if not hit` },
      lockdown: { icon: `LOCK`, desc: `Prevent draw from block` },
      drawOnBlock: { icon: `DRAW`, desc: `+1 handsize if blocked a strike` },
      backstep: { icon: `STEP`, desc: `Beats normal/special strikes of speed 8 or higher` },
      undodgeable: { icon: `CAN'T DODGE`, desc: `Cannot be dodged` },
      unblockable: { icon: `CAN'T BLOCK`, desc: `Cannot be blocked` },
      freeze: { icon: `FREEZE`, desc: `If this hits on the bot's turn, skip your next main phase` },
      oblivion: { icon: `BREAK`, desc: `If this hits, remove a random discarded card from the game` },
      transform: { icon: `DRAGON`, desc: `Transforms into a dragon` },
  };
  const FLAG_NAMES = Object.keys(FLAG_DEFS);
  /* Move description shorthand (case sensitive):
    - A..J : normals
    - t, l, h, b, d: throw, low/high/full block, dodge
    - 1, 2 : super 1/2
    - !, ? : ability, gem ability
    - S, U : gem special, burst
  */

  //-- Move creation helpers --
  const MOVE_DEFAULTS = {
      damage: 0,
      speed: 0,
      level: 0,
      blockDamage: 0,
      selfDamage: 0,
      selfHeal: 0,
      pumpDamage: [],
      meter: 0,
      height: StrikeHeight.Mid,
      armor: ArmorType.None,
  };
  const BLOCK_LOW = {
      ...MOVE_DEFAULTS,
      type: MoveType.BlockLow,
      drawOnBlock: true,
      recur: true,
  };
  const BLOCK_HIGH = {
      ...MOVE_DEFAULTS,
      type: MoveType.BlockHigh,
      drawOnBlock: true,
      recur: true,
  };
  const BLOCK_FULL = {
      ...MOVE_DEFAULTS,
      type: MoveType.BlockFull,
      drawOnBlock: true,
      recur: true,
  };
  function mStrike(damage, speed, overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Strike,
          damage,
          speed,
          ...overrides,
      };
  }
  function mThrow(damage, speed, overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Throw,
          damage,
          speed,
          knockdown: true,
          ...overrides,
      };
  }
  function mProjectile(damage, speed, overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Projectile,
          damage,
          speed,
          level: 1,
          recur: true,
          lockdown: true,
          ...overrides,
      };
  }
  function mDodge(overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Dodge,
          ...overrides,
      };
  }
  //-- Parsing --
  function moveset(def) {
      const namedMoves = {};
      for (let name in def) {
          const move = def[name];
          namedMoves[name] = { name, ...move };
      }
      return namedMoves;
  }
  function convertShorthand(moveset, moveString, overrides) {
      const moves = moveString
          .split('')
          .filter(c => c !== '+')
          .map(name => moveset[name]);
      const first = moves[0];
      const last = moves[moves.length - 1];
      const hasFollowup = moveString.length > 1;
      const description = hasFollowup
          ? [moveString[0], ' → ', moveString.slice(1)].join('')
          : moveString[0];
      const skipDescription = (first.type == MoveType.BlockHigh
          || first.type == MoveType.BlockLow
          || first.type == MoveType.BlockFull);
      let totalDamage = 0;
      let lastMove = null;
      let pumpCount = -1;
      let totalAdjust = 0;
      for (let moveIndex = 0; moveIndex < moveString.length; moveIndex += 1) {
          const moveChar = moveString[moveIndex];
          const move = moveset[moveChar];
          // Update damage
          if (moveChar !== '+') {
              // Regular move
              totalDamage += move.damage;
              // Reset pump data
              lastMove = move;
              pumpCount = -1;
          }
          else {
              // Pump last move
              pumpCount += 1;
              if (!lastMove) {
                  throw Error('Pump symbol must follow a move');
              }
              if (pumpCount >= lastMove.pumpDamage.length) {
                  throw Error(`Move ${lastMove.name} cannot be pumped ${pumpCount + 1} times`);
              }
              totalDamage += lastMove.pumpDamage[pumpCount];
          }
          // Update handsize adjustment
          totalAdjust += move?.super
              ? move.meter // Super moves always cost meter
              : (moveIndex === 0 ? 0 : 1); // First card is free!
      }
      return {
          // Determined by first move
          type: first.type,
          blockDamage: first.blockDamage,
          selfDamage: first.selfDamage,
          selfHeal: first.selfHeal,
          speed: first.speed,
          level: first.level,
          height: first.height,
          recur: first.recur,
          drawOnBlock: first.drawOnBlock,
          lockdown: first.lockdown,
          super: first.super,
          unsafe: first.unsafe,
          always: first.super,
          backstep: first.backstep,
          armor: first.armor,
          undodgeable: first.undodgeable,
          unblockable: first.unblockable,
          transform: first.transform,
          // Determined by last move
          knockdown: last.knockdown,
          edge: last.edge,
          // Determined by combo
          damage: totalDamage,
          adjust: -totalAdjust,
          description: skipDescription ? '' : description,
          firstDamage: hasFollowup ? first.damage : 0,
          freeze: moves.some(m => m.freeze),
          oblivion: moves.some(m => m.oblivion),
          // Allow explicit overrides
          ...overrides,
      };
  }
  function parseMove(shorthand, moveset) {
      // Move list with override
      if (Array.isArray(shorthand)) {
          const [moveString, overrides] = shorthand;
          return convertShorthand(moveset, moveString, overrides);
      }
      // Move list
      if (typeof shorthand === 'string') {
          return convertShorthand(moveset, shorthand, {});
      }
      // Explicit choice
      if (typeof shorthand === 'object') {
          return shorthand;
      }
      throw RangeError('Invalid shorthand descriptor: ' + shorthand);
  }
  /** Hitback moves are a bit different, apply adjustments here */
  function asHitback(original) {
      const hitback = {
          ...original,
          // Remove data irrelevant for hitback
          always: false,
          unsafe: false,
          backstep: false,
          recur: false,
          lockdown: false,
          speed: 0,
          blockDamage: 0,
          firstDamage: 0,
      };
      // Normal moves count as an extra card spent, super moves only consider meter
      if (!hitback.super) {
          hitback.adjust -= 1;
      }
      return hitback;
  }

  function applyOverride(base, override) {
      const choices = override.choices.map((c, i) => {
          return c ?? base.choices[i];
      });
      return {
          choices,
          hitback: override.hitback ?? base.hitback
      };
  }
  function modifyRow(row, change) {
      return {
          choices: row.choices.map(c => {
              return change({ ...c });
          }),
          hitback: !row.hitback ? undefined : change({ ...row.hitback })
      };
  }
  function modifyKnockdown(input) {
      return modifyRow(input, c => {
          if (c.speed && c.speed < 10) {
              c.speed = 10;
          }
          return c;
      });
  }
  function removeHandsizeChanges(input) {
      return modifyRow(input, c => {
          c.adjust = 0;
          c.recur = false;
          c.drawOnBlock = false;
          return c;
      });
  }
  function bot(moveset, init) {
      const moveParser = (c) => parseMove(c, moveset);
      const overrideParser = (c) => c === null ? null : parseMove(c, moveset);
      return {
          name: init.name,
          difficulty: init.difficulty,
          normal: init.normal.map(i => ({
              minHand: i.min,
              maxHand: i.max,
              choices: i.choices.map(moveParser),
              hitback: asHitback(moveParser(i.hitback)),
          })),
          knockdown: {
              choices: init.knockdown.choices.map(moveParser),
          },
          desperate: init.desperate ? {
              choices: init.desperate.choices.map(overrideParser),
          } : undefined,
          wakeup: init.wakeup ? modifyKnockdown({
              choices: init.wakeup.choices.map(moveParser),
          }) : undefined,
          dragon: init.dragon ? removeHandsizeChanges({
              choices: init.dragon.choices.map(moveParser),
              hitback: asHitback(moveParser(init.dragon.hitback)),
          }) : undefined,
      };
  }

  // noinspection DuplicatedCode
  // Grave
  const bot1 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(3, 8, { height: StrikeHeight.Low }),
          B: mStrike(4, 7, { height: StrikeHeight.Low }),
          C: mStrike(5, 6),
          D: mStrike(6, 5, { height: StrikeHeight.High }),
          E: mStrike(7, 4, { height: StrikeHeight.High }),
          t: mThrow(7, 5),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mProjectile(8, 7, { blockDamage: 4 }),
          Y: mStrike(10, 11, { blockDamage: 2, unsafe: true }),
          Z: mStrike(7, 7, { blockDamage: 1, height: StrikeHeight.High }),
          // Super
          1: mStrike(20, 15, { super: true, meter: 2, blockDamage: 1, unsafe: true }),
          2: mDodge({ super: true, meter: 2, damage: 30 }),
      });
      return bot(MOVES, {
          name: 'Glass Monk',
          difficulty: 1,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 't', 'BZ', 'ZC', 'X', 'X'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'ABC', 'Y', 'X', 'X'], hitback: 'Y' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'tCD', 'tCD', 'ABCX', 'ABCX', 'dt'], hitback: 'Y' },
              { min: 11, max: 12, choices: ['2', 'dt', 'tDE', 'tDE', 'ABCX', 'Y', '1', '1'], hitback: '1' },
          ],
          knockdown: { choices: ['h', 't', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'] },
          desperate: { choices: [null, null, null, null, '1', '1', '1', '1'] },
      });
  }());
  // Setsuki
  const bot2 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(2, 9, { height: StrikeHeight.Low }),
          B: mStrike(3, 8, { height: StrikeHeight.Low }),
          C: mStrike(4, 7, { height: StrikeHeight.High }),
          D: mStrike(5, 6, { height: StrikeHeight.High }),
          E: mStrike(6, 5),
          t: mThrow(6, 6),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mStrike(5, 8, { blockDamage: 1, height: StrikeHeight.High }),
          Y: mStrike(1, 9, { blockDamage: 1, pumpDamage: [4, 4] }),
          Z: mStrike(5, 7, { blockDamage: 2, pumpDamage: [3, 3] }),
          // Super
          1: mStrike(17, 9, { super: true, meter: 2, blockDamage: 3 }),
          2: mDodge({ super: true, meter: 2, damage: 30 }), // Fully pumped
      });
      return bot(MOVES, {
          name: 'Fox Primus',
          difficulty: 2,
          normal: [
              { min: 5, max: 6, choices: ['tB', 'tC', 'AB', 'AB', 'AB', 'CD', 'CD', 'dt'], hitback: 'tC' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'BCD', 'CDE', 'dY++', 'dY++'], hitback: 'CDE' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'tCDE', 'tCDE', 'ABXDE', 'CDXDE', 'd1'], hitback: 'tCDE' },
              { min: 11, max: 12, choices: ['2', '2', 'tZ++DE', 'tZ++DE', 'ABCD1', 'CDE1', 'Y++DE1', '1'], hitback: 'Y++DE1' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 'l', 'h', 't', 'BCD'] },
      });
  }());
  // Rook
  const bot3 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(5, 7, { height: StrikeHeight.Low, knockdown: true, armor: ArmorType.Medium }),
          C: mStrike(6, 5, { height: StrikeHeight.Low, armor: ArmorType.Medium }),
          D: mStrike(7, 4, { armor: ArmorType.Medium }),
          E: mStrike(8, 3, { height: StrikeHeight.High, armor: ArmorType.Medium }),
          F: mStrike(9, 2, { height: StrikeHeight.High, armor: ArmorType.Medium }),
          t: mThrow(12, 8),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(), // Instead of entangling vines
          // Special
          X: mStrike(6, 6, { blockDamage: 2 }),
          Y: mStrike(14, 5, { blockDamage: 1, armor: ArmorType.Heavy }), // Fully pumped, for free
          Z: mThrow(16, 9, { knockdown: false, armor: ArmorType.Light }),
          // Super
          1: mStrike(20, 12, { super: true, meter: 3, blockDamage: 3 }), // Fully pumped
          2: mThrow(50, 15, { super: true, meter: 3, knockdown: false }),
      });
      return bot(MOVES, {
          name: 'Colossus',
          difficulty: 3,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 'h', 't', 't', 'A', 'EF'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'Z', 'AXD', 'CDE', 'EF'], hitback: 't' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'h', 't', 'Z', 'Z', 'AXD'], hitback: 'Z' },
              { min: 11, max: 12, choices: ['2', '2', '2', '1', 'Y', 'dZ', 'dZ', 'EF'], hitback: '2' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 't', 'Y', 'Y', '1', '1'] },
          wakeup: { choices: ['l', 'h', 't', 't', 'CDE', 'EF', 'EF', 'Z'] },
      });
  }());
  // DeGrey
  const bot4 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(4, 8, { height: StrikeHeight.Low }),
          B: mStrike(4, 7),
          D: mStrike(5, 6, { height: StrikeHeight.Low }),
          E: mStrike(6, 5, { height: StrikeHeight.Low }),
          F: mStrike(7, 4, { height: StrikeHeight.High }),
          t: mThrow(8, 4),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mStrike(7, 2, { blockDamage: 2, backstep: true }),
          Y: mStrike(14, 1, { blockDamage: 4, backstep: true, knockdown: true, unsafe: true }),
          Z: mProjectile(1, 4, { blockDamage: 1, level: 2, edge: true, recur: false, lockdown: false }),
          // Super
          1: mDodge({ super: true, meter: 0, recur: true }),
          2: mStrike(20, 11, { super: true, meter: 2, blockDamage: 2 }),
      });
      const S1DEF = ['1DEF', { always: false }];
      const S1EF2 = ['1EF2', { always: false }];
      return bot(MOVES, {
          name: 'Twilight Baron',
          difficulty: 4,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 't', 't', 'AB', 'AB', 'Y'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'YEF', 'YEF', 'Y', 'Y'], hitback: 'Y' },
              { min: 9, max: 10, choices: ['l', 'h', 'tDE', 'tDE', 'YEF', 'YEF', S1DEF, 'ZDEF'], hitback: 'Y' },
              { min: 11, max: 12, choices: [S1EF2, S1DEF, 'tDE', 'tDE', 'YEF', 'YEF', '2', 'ZEF2'], hitback: '2' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 't', 'EF', '2', '2'] },
          wakeup: { choices: ['l', 'h', 't', 't', 'EF', 'FZF', 'FZF', 'YEF'] },
      });
  }());
  // Dragonborn Centurion
  const bot5 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(3, 8, { height: StrikeHeight.Low }),
          B: mStrike(4, 7),
          C: mStrike(5, 6),
          D: mStrike(6, 5, { height: StrikeHeight.Low }),
          E: mStrike(7, 4, { height: StrikeHeight.High }),
          t: mThrow(8, 6),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mProjectile(12, 7, { blockDamage: 5 }),
          Y: mProjectile(16, 6, { blockDamage: 6, level: 2, edge: true, lockdown: false }),
          Z: mStrike(10, 11, { blockDamage: 2, unsafe: true }),
          // Dragon moves
          b: { ...BLOCK_FULL, drawOnBlock: false, recur: false },
          x: mProjectile(28, 7, { blockDamage: 6, level: 2, lockdown: false }),
          y: mStrike(18, 13, { blockDamage: 2, }),
          z: mThrow(23, 7, { knockdown: false }),
          // Super
          1: mStrike(20, 15, { super: true, meter: 2, blockDamage: 1, unsafe: true }),
          2: mStrike(1, 15, { super: true, meter: 3, transform: true }),
      });
      return bot(MOVES, {
          name: 'Dragonborn Centurion',
          difficulty: 5,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 't', 'AB', 'DE', 'X', 'Y'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'AB', 'Z', 'X', 'Y'], hitback: 'Y' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'tCD', 'tCD', 'ABX', 'X', 'dY'], hitback: 'Y' },
              { min: 11, max: 12, choices: ['2', '2', 'tDE', 'tDE', 'ABX', 'Z', '1', '1'], hitback: '1' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 'tCD', 'Z', 'Z', '2'] },
          dragon: { choices: ['l', 'h', 'b', 'dz', 'x', 'y', 'z', 'z'], hitback: 'z' },
      });
  }());
  // Gloria
  const bot6 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(3, 8, { height: StrikeHeight.High }),
          B: mStrike(4, 7, { height: StrikeHeight.Low }),
          D: mStrike(5, 6),
          E: mStrike(6, 5, { height: StrikeHeight.Low }),
          F: mStrike(7, 4),
          t: mThrow(6, 3),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mProjectile(8, 7, { blockDamage: 4, knockdown: true }),
          Y: mStrike(6, 5, { blockDamage: 2, pumpDamage: [7], knockdown: true, undodgeable: true }),
          Z: mStrike(5, 7, { blockDamage: 2 }),
          // Super
          1: mStrike(31, 13, { super: true, meter: 4, blockDamage: 2, unsafe: true }),
          2: mStrike(10, 15, { super: true, meter: 1, blockDamage: 10, selfDamage: 10 }),
      });
      const BZ = ['BZ', { adjust: 0 }];
      const ABZ = ['ABZ', { adjust: -1 }];
      const ABZF = ['ABZF', { adjust: -2 }];
      return bot(MOVES, {
          name: 'Soothing Monk',
          difficulty: 1,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 't', 'AB', BZ, 'X', 'X'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', ABZ, 'Y+E', 'X', 'X'], hitback: 't' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'tDE', 'Y+DE', 'X', '2', 'dt'], hitback: 'Y+' },
              { min: 11, max: 12, choices: ['d1', 'dt', 'tEF', 'tEF', 'Y+DE', ABZF, '1', '1'], hitback: '1' },
          ],
          knockdown: { choices: ['h', 't', 't', '2', '2', '2', '2', '2'] },
      });
  }());
  // Bigby
  const bot7 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(5, 7, { height: StrikeHeight.High }),
          B: mStrike(6, 5),
          C: mStrike(7, 4, { height: StrikeHeight.High }),
          D: mStrike(8, 3, { height: StrikeHeight.Low }),
          E: mStrike(8, 6, { knockdown: true }),
          t: mThrow(9, 8),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(), // Slow dodge
          // Special
          X: mStrike(14, 1, { blockDamage: 4, edge: true, backstep: true }),
          Y: mStrike(9, 6, { blockDamage: 3, pumpDamage: [5], knockdown: true }),
          Z: mThrow(16, 9, { knockdown: false }), // armor: light
          // Super
          1: mStrike(10, 9, { super: true, meter: 2, blockDamage: 2 }),
          2: mThrow(40, 14, { super: true, meter: 3, knockdown: false }),
      });
      return bot(MOVES, {
          name: 'Whitestar Grappler',
          difficulty: 2,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 'h', 't', 't', 'AB', 'DE'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'Z', 'X', 'ABC', 'DE'], hitback: 't' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'h', 't', 'Z', 'Z', 'XD'], hitback: 'Z' },
              { min: 11, max: 12, choices: ['2', '2', '2', '1', 'XD', 'dZ', 'dZ', 'ABC'], hitback: '2' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 'l', 'h', 't', 'DE'] },
      });
  }());
  // Onimaru
  const bot8 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(5, 7, { height: StrikeHeight.Low, edge: true, pumpDamage: [5] }),
          C: mStrike(10, 4, { height: StrikeHeight.Low, edge: true, pumpDamage: [5] }),
          E: mStrike(10, 3, { armor: ArmorType.Heavy, edge: true, pumpDamage: [6] }),
          G: mStrike(10, 2, { height: StrikeHeight.High, edge: true, pumpDamage: [8] }),
          J: mStrike(10, 1, { height: StrikeHeight.High, edge: true, pumpDamage: [10] }),
          t: mThrow(8, 3, { pumpDamage: [4, 4] }),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mStrike(10, 7, { blockDamage: 1, pumpDamage: [10] }),
          Y: mStrike(10, 12, { blockDamage: 2, unsafe: true }),
          Z: mStrike(8, 6, { blockDamage: 3, pumpDamage: [12], armor: ArmorType.Heavy }),
          // Super
          2: mStrike(20, 8, { super: true, meter: 2, blockDamage: 10, unblockable: true }),
      });
      return bot(MOVES, {
          name: 'Ancient Hero',
          difficulty: 3,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 'h', 'dG', 't', 'C', 'E'], hitback: 'C' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 'dG', 't+', 'A', 'C+', 'E+'], hitback: 'C' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'h', 't++', 'A+', 'X+', 'E+'], hitback: 'G+' },
              { min: 11, max: 12, choices: ['dJ+', 'dJ+', 't++', 'X+', 'Y', 'Z+', '2', '2'], hitback: 'J+' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 't+', 'Y', 'Y', 'Y', 'E+'] },
      });
  }());
  // Gwen
  const bot9 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(2, 9, { height: StrikeHeight.Low }),
          B: mStrike(3, 8, { height: StrikeHeight.Low }),
          C: mStrike(4, 7, { height: StrikeHeight.High }),
          D: mStrike(5, 6, { height: StrikeHeight.High }),
          E: mStrike(6, 5),
          t: mThrow(6, 6, { freeze: true }),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mStrike(4, 8, { blockDamage: 3, pumpDamage: [4, 4], edge: true }),
          Y: mStrike(6, 12, { blockDamage: 1, unsafe: true, selfHeal: 6 }),
          Z: mProjectile(7, 6, { blockDamage: 5, pumpDamage: [7], freeze: true }),
          // Super
          1: mStrike(8, 6, { super: true, meter: 2, selfHeal: 10 }),
          2: mStrike(16, 9, { super: true, meter: 2 }), // Fully pumped
      });
      const dt = ['dt', { freeze: false }];
      const wt = ['t', { freeze: false }];
      return bot(MOVES, {
          name: 'Jandra, the Negator',
          difficulty: 4,
          normal: [
              { min: 5, max: 6, choices: ['tB', 'tC', 'AB', 'AB', 'AB', 'CD', 'CD', dt], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'BCD', 'CDE', 'dZ+', 'dZ+'], hitback: 't' },
              { min: 9, max: 10, choices: ['l', 'h', 'tCDE', 'tCDE', 'BXDE', 'BXDE', 'CDXDE', 'd2'], hitback: '2' },
              { min: 11, max: 12, choices: ['1', '1', 'tX++DE', 'tX++DE', 'ABCD2', 'CDE2', 'dZ+', '2'], hitback: '2' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 'Y', 'Y', '1', '1'] },
          wakeup: { choices: ['l', 'h', wt, wt, 'BCDE', 'BCDE', 'CDE', 'CDE'] },
      });
  }());
  // Dragonborn Firebat
  const bot10 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(3, 8, { height: StrikeHeight.Low }),
          B: mStrike(4, 7),
          C: mStrike(5, 6),
          D: mStrike(6, 5, { height: StrikeHeight.Low }),
          E: mStrike(7, 4, { height: StrikeHeight.High }),
          t: mThrow(8, 6, { oblivion: true }),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mProjectile(12, 7, { blockDamage: 5 }),
          Y: mProjectile(16, 6, { blockDamage: 6, level: 2, edge: true, lockdown: false }),
          Z: mStrike(10, 11, { blockDamage: 2, unsafe: true }),
          // Dragon moves
          b: { ...BLOCK_FULL, drawOnBlock: false, recur: false },
          x: mProjectile(28, 7, { blockDamage: 6, level: 2, lockdown: false, oblivion: true }),
          y: mStrike(18, 13, { blockDamage: 2, oblivion: true }),
          z: mThrow(23, 7, { knockdown: false, oblivion: true }),
          // Super
          1: mStrike(20, 15, { super: true, meter: 2, blockDamage: 1, unsafe: true, oblivion: true }),
          2: mStrike(1, 15, { super: true, meter: 3, transform: true }),
      });
      return bot(MOVES, {
          name: 'Dragonborn Firebat',
          difficulty: 5,
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 't', 'AB', 'DE', 'X', 'Y'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'AB', 'Z', 'X', 'Y'], hitback: 'Y' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'tCD', 'tCD', 'ABX', 'X', 'dY'], hitback: 'Y' },
              { min: 11, max: 12, choices: ['2', '2', 'tDE', 'tDE', 'ABX', 'Z', '1', '1'], hitback: '1' },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 'tCD', 'Z', 'Z', '2'] },
          dragon: { choices: ['l', 'h', 'b', 'dz', 'x', 'y', 'z', 'z'], hitback: 'z' },
      });
  }());
  const BOTS = [
      bot1,
      bot2,
      bot3,
      bot4,
      bot5,
      bot6,
      bot7,
      bot8,
      bot9,
      bot10,
  ];

  //-- State --
  let handSize = 9;
  let choiceIndex = 0;
  let mode = '';
  let hitback = false;
  let desperate = false;
  let chosenBotID = undefined;
  let chosenBot = undefined;
  let showPicker = true;
  let showAbout = false;
  let showHelp = false;
  //-- Actions --
  const choiceLeft = () => { choiceIndex = clamp(choiceIndex - 1, 0, 7); };
  const choiceRight = () => { choiceIndex = clamp(choiceIndex + 1, 0, 7); };
  const choiceRandom = () => { choiceIndex = Math.floor(Math.random() * 8); };
  const handsizeDown = () => { handSize = clamp(handSize - 1, 5, 12); };
  const handsizeUp = () => { handSize = clamp(handSize + 1, 5, 12); };
  const toggleKnockdown = () => { mode = mode ? '' : 'knockdown'; };
  const toggleWakeup = () => { mode = mode ? '' : 'wakeup'; };
  const toggleHitback = () => { hitback = !hitback; };
  const toggleDesperate = () => { desperate = !desperate; };
  const toggleDragon = () => { mode = mode ? '' : 'dragon'; };
  const displayAbout = () => { showAbout = !showAbout; };
  const displayHelp = () => { showHelp = !showHelp; };
  const displayPicker = () => { showPicker = true; };
  const changeCharacter = (data) => {
      const chosen = data.char;
      if (chosen) {
          chosenBotID = parseInt(chosen, 10);
          chosenBot = BOTS[chosenBotID];
          showPicker = false;
          save();
          // Reset match state
          handSize = 9;
          choiceIndex = 0;
          mode = '';
          hitback = false;
          desperate = false;
      }
  };
  //-- Persistence --
  const STORAGE_KEY = 'y2_assist';
  function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
          chosenBotID
      }));
  }
  function load() {
      const rawData = localStorage.getItem(STORAGE_KEY);
      if (rawData) {
          const data = JSON.parse(rawData);
          chosenBotID = data.chosenBotID;
          // Update derived state
          chosenBot = BOTS[chosenBotID];
          showPicker = !chosenBotID;
      }
  }
  //-- Utils --
  function style(props) {
      const attributeValue = Object.entries(props)
          .map(([key, value]) => `${key}: ${value}`)
          .join('; ');
      return `style="${attributeValue}"`;
  }
  function when(condition, template) {
      return condition ? template : '';
  }
  function clamp(value, min, max) {
      if (value < min) {
          return min;
      }
      if (value > max) {
          return max;
      }
      return value;
  }
  //-- Rendering --
  function typeColor(type) {
      switch (type) {
          case MoveType.Dodge: return '#080';
          case MoveType.Throw: return '#000';
          case MoveType.Strike:
              return '#f33';
          case MoveType.Projectile:
              return '#f90';
          case MoveType.BlockLow:
          case MoveType.BlockHigh:
          case MoveType.BlockFull:
              return '#00f';
      }
  }
  function typeClass(type) {
      switch (type) {
          case MoveType.BlockLow:
          case MoveType.BlockHigh:
          case MoveType.BlockFull:
              return 'block';
          case MoveType.Projectile:
              return 'projectile';
          default: return '';
      }
  }
  function toggleClass(enabled) {
      return enabled ? 'on' : 'off';
  }
  function heightStyle(height) {
      switch (height) {
          case StrikeHeight.Low: return { top: '55%' };
          case StrikeHeight.Mid: return { display: 'none' };
          case StrikeHeight.High: return { top: '25%' };
      }
  }
  function renderMove(choice) {
      const { type, damage, firstDamage, blockDamage, speed, adjust, always, height, level, description, armor, selfDamage, selfHeal } = choice;
      const hasGap = type === MoveType.BlockLow || type === MoveType.BlockHigh;
      const gapPosition = type === MoveType.BlockHigh ? '50%' : '0';
      const reversal = speed > 10;
      const levelText = Array(level).fill('I').join('');
      const flags = [];
      for (const flagname of FLAG_NAMES) {
          if (choice[flagname]) {
              flags.push(FLAG_DEFS[flagname].icon);
          }
      }
      if (armor === ArmorType.Light) {
          flags.push(`[L]`);
      }
      if (armor === ArmorType.Medium) {
          flags.push(`[M]`);
      }
      if (armor === ArmorType.Heavy) {
          flags.push(`[H]`);
      }
      if (selfDamage) {
          flags.push(`${selfDamage} SELF DMG`);
      }
      if (selfHeal) {
          flags.push(`${selfHeal} SELF HEAL`);
      }
      return `
        <div class="damage ${typeClass(type)}" style="background: ${typeColor(type)}">
            ${!damage ? '' : damage}
            ${!firstDamage ? '' : `(${firstDamage})`}
            ${!hasGap ? '' : `
                <div class="blockGap" ${style({ top: gapPosition })}></div>
            `}
        </div>
        <div class="description"> ${description} </div>
        <div class="flags"> ${flags.join('<br> ')} </div>
        <div class="height" ${style(heightStyle(height))}></div>

        ${when(level, `<div class="level"> ${levelText} </div>`)}
        ${when(speed, `<div class="speed ${when(reversal, "reversal")}"> ${speed} </div>`)}
        ${when(blockDamage, `<div class="blockDamage"> ${blockDamage} </div>`)}
        ${when(adjust, `<div class="adjust"> ${adjust}${always ? '!' : ''} </div>`)}
    `;
  }
  function getChoiceRow(bot) {
      // Default choice
      const rowIndex = Math.floor((handSize - 5) / 2);
      let row = bot.normal[rowIndex];
      // Mode-specific overrides
      if (bot.desperate && desperate) {
          row = applyOverride(row, bot.desperate);
      }
      if (mode === 'knockdown') {
          row = applyOverride(row, bot.knockdown);
      }
      if (bot.wakeup && mode === 'wakeup') {
          row = applyOverride(row, bot.wakeup);
      }
      if (bot.dragon && mode === 'dragon') {
          row = applyOverride(row, bot.dragon);
      }
      return row;
  }
  function getChoice(bot) {
      const row = getChoiceRow(bot);
      if (hitback) {
          return row.hitback;
      }
      return row.choices[choiceIndex];
  }
  function renderContent() {
      if (showAbout) {
          return renderAbout();
      }
      if (showHelp) {
          return renderHelp();
      }
      if (showPicker) {
          return renderPicker(BOTS);
      }
      else {
          return renderBot(chosenBot);
      }
  }
  function renderBot(bot) {
      if (!bot) {
          return `
            <div class="header">
                <button class="fixed" data-action="picker">Change</button>
            </div>
            <h1>⚠ Work in progress! ⚠</div>
        `;
      }
      const choice = getChoice(bot);
      const isKnockdown = mode == 'knockdown';
      const isWakeup = mode == 'wakeup';
      const isDragon = mode == 'dragon';
      const choiceText = hitback ? '*' : choiceIndex + 1;
      const showDesperate = !!bot.desperate;
      const showWakeup = !!bot.wakeup;
      const showDragon = !!bot.dragon;
      return `
        <div class="screen main">
            <div class="header">
                <button class="fixed" data-action="about">About</button>
                <button class="fixed" data-action="help">Help</button>
            </div>
            <div class="header">
                <span>[${handSize}] / ${choiceText}</span>
                <span> ${(bot.name)}</span>
                <button class="fixed" data-action="picker">Change</button>
            </div>
            <div class="move"> ${renderMove(choice)} </div>
            <div class="toggles">
                ${when(showDragon, `
                    <button data-action="dragon" class="${toggleClass(isDragon)}"> Dragon </button>
                `)}
                ${when(showDesperate, `
                    <button data-action="desperate" class="${toggleClass(desperate)}"> Desperation </button>
                `)}
                ${when(showWakeup, `
                    <button data-action="wakeup" class="${toggleClass(isWakeup)}"> Wakeup </button>
                `)}
                <button data-action="knockdown" class="${toggleClass(isKnockdown)}"> Knockdown </button>
                <button data-action="hitback" class="${toggleClass(hitback)}"> Hitback </button>
            </div>
            <div class="controls">
                <button data-action="left"> &lt; </button>
                <button data-action="right"> &gt; </button>
                
                <button class="large" data-action="roll"> ROLL </button>
                
                <button data-action="down"> - </button>
                <button data-action="up"> + </button>
            </div>
        </div>
    `;
  }
  function starsFor(difficulty) {
      const filler = 5 - difficulty;
      return '★'.repeat(difficulty) + '☆'.repeat(filler);
  }
  function renderPicker(bots) {
      return `
        <div class="screen picker">
            ${bots.map((b, index) => `
                <button data-action="pick" data-char="${index}">
                    ${b.name} <br>
                    ${starsFor(b.difficulty)}
                </button>            
            `).join('\n')}
        </div>    
    `;
  }
  function link(url, text) {
      return `<a href="${url}" target="_blank">${text}</a>`;
  }
  function renderAbout() {
      const yomi2 = `https://www.sirlingames.com/yomi2`;
      const handmade = `https://hero.handmade.network/`;
      const source = `https://github.com/pkt-zer0/y2-assist`;
      return `
        <div class="screen about">
            <div class="controls">
                <button data-action="about">Close</button>
            </div>
            <p>
                Unofficial solo mode assistant for <br>
                Yomi 2 from ${link(yomi2, `Sirlin Games`)}.
            </p>
            <p>
                Lovingly ${link(handmade, `handmade`)} by<br>
                <b>Kovács "pkt" György</b>.
            </p>
            <p>${link(source, `Source code`)}<br> also available for the curious.</p>
        </div>    
    `;
  }
  function renderHelp() {
      return `
        <div class="screen help">
            <div class="controls">
                <button data-action="help">Close</button>
            </div>
            <div class="content">            
            ${FLAG_NAMES.map(flag => {
        const def = FLAG_DEFS[flag];
        return `
                <article>
                    <h4>
                        ${def.icon} <code>[${flag}]</code> 
                    </h4>
                    <p>${def.desc}</p>
                </article>`;
    }).join('\n')}
            </div>
        </div>    
    `;
  }
  function main() {
      const html = document.documentElement;
      const container = document.querySelector('#main');
      const KEY_HANDLERS = {
          "ArrowLeft": choiceLeft,
          "ArrowRight": choiceRight,
          "ArrowUp": handsizeDown,
          "ArrowDown": handsizeUp,
          "r": choiceRandom,
          "k": toggleKnockdown,
          "w": toggleWakeup,
          "h": toggleHitback,
          "d": toggleDesperate,
          "t": toggleDragon,
      };
      document.addEventListener('keydown', (e) => {
          const handler = KEY_HANDLERS[e.key];
          if (handler) {
              handler();
              render();
          }
      });
      const ACTION_HANDLERS = {
          roll: choiceRandom,
          left: choiceLeft,
          right: choiceRight,
          up: handsizeUp,
          down: handsizeDown,
          // Toggles
          knockdown: toggleKnockdown,
          wakeup: toggleWakeup,
          hitback: toggleHitback,
          desperate: toggleDesperate,
          dragon: toggleDragon,
          // Character picker
          picker: displayPicker,
          pick: changeCharacter,
          // Misc
          about: displayAbout,
          help: displayHelp,
      };
      html.addEventListener('click', e => {
          const target = e.target;
          if (target instanceof HTMLButtonElement) {
              const handler = ACTION_HANDLERS['' + target.dataset.action];
              if (handler) {
                  handler(target.dataset);
                  render();
              }
          }
      });
      function render() {
          container.innerHTML = renderContent();
      }
      // Rerender with initial state
      load();
      render();
  }
  document.addEventListener('DOMContentLoaded', main);

})();

        </script>
    
</body>
</html>