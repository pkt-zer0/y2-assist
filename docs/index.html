<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Y2 assistant</title>
    <!--suppress CssUnusedSymbol -->
    <style>
        html {
            font-size: 4vw;
            user-select: none;
        }
        html, body {
            padding: 0;
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
        #main, .screen {
            height: 100%;
        }
        * {
            box-sizing: border-box;
            touch-action: manipulation;
        }
        .screen.main, .screen.picker {
            display: flex;
            flex-direction: column;
        }
        .controls, .toggles, .header {
            display: flex;
            width: 100%;
            height: 3rem;
            font-size: 1.75rem;
            justify-content: space-between;
        }
        .toggles {
            height: 2rem;
        }
        button {
            background: #f0f0f0;
            color: black;

            font-size: 1rem;
            flex-basis: 0;
            flex-grow: 1;
            margin: 0 0.5rem;
            border-width: 0.0625rem;
        }
        button.large {
            flex-grow: 2;
        }
        button.fixed {
            flex-grow: 0;
        }
        button.on {
            background: #333;
            color: white;
        }
        .move {
            position: relative;
            width: 75vw;
            aspect-ratio: 1;
            font-size: 3rem;
            margin: auto;
        }
        .damage, .blockDamage, .speed, .adjust, .flags, .height, .level {
            display: flex;
            position: absolute;
            align-items: center;
            justify-content: center;
        }
        .description {
            position: absolute;
            left: 5%;
            font-size: 0.8em;
        }
        .damage {
            width: 50%;
            height: 50%;
            left: 20%;
            top: 20%;
            color: white;
            border-radius: 50%;
            overflow: hidden;
        }
        .damage.block {
            border-radius: 10% 10% 50% 50%;
        }
        .damage.projectile {
            border-radius: 20% 50% 50% 20%;
        }
        .blockDamage {
            background: lightblue;
            width : 20%;
            height: 20%;
            left  : 58%;
            top   : 58%;
            text-align: center;
            border-radius: 10% 10% 50% 50%;
        }
        .blockGap {
            position: absolute;
            background: gray;
            width: 100%;
            height: 50%;
        }
        .speed {
            background: palegoldenrod;
            color: grey;
            border-color: black;
            border-width: 0.0625rem;
            border-style: solid;
            top: 10%;
            left: 60%;
            width: 20%;
            height: 20%;
            border-radius: 50%;
        }
        .adjust {
            background: sandybrown;
            width : 20%;
            height: 30%;
            left  : 80%;
            top   : 30%;
        }
        .level {
            width: 20%;
            height: 20%;
            top: 50%;
            left: 20%;
            border-radius: 25%;
            font-size: 0.80em;
            color: black;
        }
        .flags {
            top: 80%;
            width: 90%;
            font-size: 0.8em;
            text-align: center;
        }
        .height {
            background: #800;
            width: 10%;
            height: 10%;
            left: 10%;
            border-radius: 50%;
        }
    </style>
    
</head>
<body>
<div id="main"></div>

        <script type="application/javascript">
            (function () {
  'use strict';

  var MoveType;
  (function (MoveType) {
      MoveType[MoveType["Dodge"] = 0] = "Dodge";
      MoveType[MoveType["Throw"] = 1] = "Throw";
      // Attacks
      MoveType[MoveType["Strike"] = 2] = "Strike";
      MoveType[MoveType["Projectile"] = 3] = "Projectile";
      // Blocks
      MoveType[MoveType["BlockLow"] = 4] = "BlockLow";
      MoveType[MoveType["BlockHigh"] = 5] = "BlockHigh";
  })(MoveType || (MoveType = {}));
  var StrikeHeight;
  (function (StrikeHeight) {
      StrikeHeight[StrikeHeight["Low"] = 0] = "Low";
      StrikeHeight[StrikeHeight["Mid"] = 1] = "Mid";
      StrikeHeight[StrikeHeight["High"] = 2] = "High";
  })(StrikeHeight || (StrikeHeight = {}));
  /* Move description shorthand (case sensitive):
    - A..J : normals
    - t, l, h, b, d: throw, low/high/full block, dodge
    - 1, 2 : super 1/2
    - !, ? : ability, gem ability
    - S, U : gem special, burst
  */

  function sumBy(items, selector) {
      return items.map(selector).reduce((acc, cur) => acc + cur);
  }
  //-- Move creation helpers --
  const MOVE_DEFAULTS = {
      damage: 0,
      speed: 0,
      level: 0,
      blockDamage: 0,
      height: StrikeHeight.Mid,
  };
  function mStrike(damage, speed, overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Strike,
          damage,
          speed,
          ...overrides,
      };
  }
  function mThrow(damage, speed, overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Throw,
          damage,
          speed,
          knockdown: true,
          ...overrides,
      };
  }
  function mProjectile(damage, speed, overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Projectile,
          damage,
          speed,
          level: 1,
          recur: true,
          lockdown: true,
          ...overrides,
      };
  }
  function mDodge(overrides = {}) {
      return {
          ...MOVE_DEFAULTS,
          type: MoveType.Dodge,
          ...overrides,
      };
  }
  //-- Parsing --
  function moveset(def) {
      const namedMoves = {};
      for (let name in def) {
          const move = def[name];
          namedMoves[name] = { name, ...move };
      }
      return namedMoves;
  }
  function choiceFromMoves(moves, overrides = {}) {
      const first = moves[0];
      const last = moves[moves.length - 1];
      const hasFollowup = moves.length > 1;
      const description = hasFollowup
          ? [first.name, ' → ', moves.slice(1).map(_ => _.name).join('')].join('')
          : first.name;
      const skipDescription = (first.type == MoveType.BlockHigh
          || first.type == MoveType.BlockLow);
      return {
          // Determined by first move
          type: first.type,
          blockDamage: first.blockDamage,
          speed: first.speed,
          level: first.level,
          height: first.height,
          recur: first.recur,
          drawOnBlock: first.drawOnBlock,
          lockdown: first.lockdown,
          super: first.super,
          unsafe: first.unsafe,
          always: first.super,
          backstep: first.backstep,
          // Determined by last move
          knockdown: last.knockdown,
          edge: last.edge,
          // Determined by combo
          damage: sumBy(moves, _ => _.damage),
          adjust: -(moves.length - 1),
          description: skipDescription ? '' : description,
          firstDamage: hasFollowup ? first.damage : 0,
          // Allow explicit overrides
          ...overrides,
      };
  }
  function convertShorthand(moveset, moveString, overrides) {
      const named = moveString.split('').map(name => moveset[name]);
      return choiceFromMoves(named, overrides);
  }
  function parseMove(shorthand, moveset) {
      // Move list with override
      if (Array.isArray(shorthand)) {
          const [moveString, overrides] = shorthand;
          return convertShorthand(moveset, moveString, overrides);
      }
      // Move list
      if (typeof shorthand === 'string') {
          return convertShorthand(moveset, shorthand, {});
      }
      // Explicit choice
      if (typeof shorthand === 'object') {
          return shorthand;
      }
      throw RangeError('Invalid shorthand descriptor: ' + shorthand);
  }

  const CHOICE_DEFAULTS = {
      description: '',
      firstDamage: 0,
      adjust: 0,
  };
  const BLOCK_LOW = {
      ...MOVE_DEFAULTS,
      ...CHOICE_DEFAULTS,
      type: MoveType.BlockLow,
      drawOnBlock: true,
      recur: true,
  };
  const BLOCK_HIGH = {
      ...MOVE_DEFAULTS,
      ...CHOICE_DEFAULTS,
      type: MoveType.BlockHigh,
      drawOnBlock: true,
      recur: true,
  };

  function applyOverride(base, override) {
      const choices = override.choices.map((c, i) => {
          return c ?? base.choices[i];
      });
      return {
          choices,
          hitback: override.hitback ?? base.hitback
      };
  }
  function bot(moveset, init) {
      const moveParser = (c) => parseMove(c, moveset);
      const overrideParser = (c) => c === null ? null : parseMove(c, moveset);
      return {
          name: init.name,
          normal: init.normal.map(i => {
              const hitback = {
                  ...moveParser(i.hitback),
                  // Remove data irrelevant for hitback
                  always: false,
                  unsafe: false,
                  speed: 0,
                  blockDamage: 0,
              };
              // Normal moves count as an extra card spent, super moves only consider meter
              if (!hitback.super) {
                  hitback.adjust -= 1;
              }
              return ({
                  minHand: i.min,
                  maxHand: i.max,
                  choices: i.choices.map(moveParser),
                  hitback: hitback,
              });
          }),
          knockdown: {
              choices: init.knockdown.choices.map(moveParser),
          },
          desperate: {
              choices: init.desperate.choices.map(overrideParser),
          }
      };
  }

  // Grave
  const bot1 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(3, 8, { height: StrikeHeight.Low }),
          B: mStrike(4, 7, { height: StrikeHeight.Low }),
          C: mStrike(5, 6),
          D: mStrike(6, 5, { height: StrikeHeight.High }),
          E: mStrike(7, 4, { height: StrikeHeight.High }),
          t: mThrow(7, 5),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(),
          // Special
          X: mProjectile(8, 7, { blockDamage: 4 }),
          Y: mStrike(10, 11, { blockDamage: 2, unsafe: true }),
          Z: mStrike(7, 7, { blockDamage: 1, height: StrikeHeight.High }),
          // Super
          1: mStrike(20, 15, { super: true, blockDamage: 1, unsafe: true }),
          2: mDodge({ super: true, damage: 30 }),
      });
      const S1 = ['1', { adjust: -2 }];
      const S2 = ['2', { adjust: -2 }];
      return bot(MOVES, {
          name: 'Glass Monk',
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 't', 'BZ', 'ZC', 'X', 'X'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'ABC', 'Y', 'X', 'X'], hitback: 'Y' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'tCD', 'tCD', 'ABCX', 'ABCX', 'dt'], hitback: 'Y' },
              { min: 11, max: 12, choices: [S2, 'dt', 'tDE', 'tDE', 'ABCX', 'Y', S1, S1], hitback: S1 },
          ],
          knockdown: { choices: ['h', 't', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'] },
          desperate: { choices: [null, null, null, null, S1, S1, S1, S1] },
      });
  }());
  // Bigby
  const bot7 = (function () {
      const MOVES = moveset({
          // Normal
          A: mStrike(5, 7, { height: StrikeHeight.High }),
          B: mStrike(6, 5),
          C: mStrike(7, 4, { height: StrikeHeight.High }),
          D: mStrike(8, 3, { height: StrikeHeight.Low }),
          E: mStrike(8, 6, { knockdown: true }),
          t: mThrow(9, 8),
          // Defense
          h: BLOCK_HIGH,
          l: BLOCK_LOW,
          d: mDodge(), // Slow dodge
          // Special
          X: mStrike(14, 1, { blockDamage: 4, edge: true, backstep: true }),
          Y: mStrike(9, 6, { blockDamage: 3, knockdown: true }), // pump: +5
          Z: mThrow(16, 9, { knockdown: false }), // armor: light
          // Super
          1: mStrike(10, 9, { super: true, blockDamage: 2 }),
          2: mThrow(40, 14, { super: true, knockdown: false }),
      });
      const S1 = ['1', { adjust: -2 }];
      const S2 = ['2', { adjust: -3 }];
      return bot(MOVES, {
          name: 'Whitestar Grappler',
          normal: [
              { min: 5, max: 6, choices: ['l', 'h', 'l', 'h', 't', 't', 'AB', 'DE'], hitback: 't' },
              { min: 7, max: 8, choices: ['l', 'h', 'l', 't', 'Z', 'X', 'ABC', 'DE'], hitback: 't' },
              { min: 9, max: 10, choices: ['l', 'h', 'l', 'h', 't', 'Z', 'Z', 'XD'], hitback: 'Z' },
              { min: 11, max: 12, choices: [S2, S2, S2, S1, 'XD', 'dZ', 'dZ', 'ABC'], hitback: S2 },
          ],
          knockdown: { choices: ['l', 'h', 'l', 'h', 'l', 'h', 't', 'DE'] },
          desperate: { choices: [null, null, null, null, null, null, null, null] },
      });
  }());
  const BOTS = {
      M1: bot1,
      F2: bot7,
  };

  //-- State --
  let handSize = 9;
  let choiceIndex = 0;
  let mode = '';
  let hitback = false;
  let desperate = false;
  let chosenBotID = undefined;
  let chosenBot = undefined;
  let showPicker = true;
  //-- Actions --
  const choiceLeft = () => { choiceIndex = clamp(choiceIndex - 1, 0, 7); };
  const choiceRight = () => { choiceIndex = clamp(choiceIndex + 1, 0, 7); };
  const choiceRandom = () => { choiceIndex = Math.floor(Math.random() * 8); };
  const handsizeDown = () => { handSize = clamp(handSize - 1, 5, 12); };
  const handsizeUp = () => { handSize = clamp(handSize + 1, 5, 12); };
  const toggleKnockdown = () => { mode = mode ? '' : 'knockdown'; };
  const toggleHitback = () => { hitback = !hitback; };
  const toggleDesperate = () => { desperate = !desperate; };
  const displayPicker = () => { showPicker = true; };
  const changeCharacter = (data) => {
      const chosen = data.char;
      if (chosen) {
          chosenBotID = chosen;
          chosenBot = BOTS[chosenBotID];
          showPicker = false;
          save();
      }
  };
  //-- Persistence --
  const STORAGE_KEY = 'y2_assist';
  function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
          chosenBotID
      }));
  }
  function load() {
      const rawData = localStorage.getItem(STORAGE_KEY);
      if (rawData) {
          const data = JSON.parse(rawData);
          chosenBotID = data.chosenBotID;
          // Update derived state
          chosenBot = BOTS[chosenBotID];
          showPicker = !chosenBotID;
      }
  }
  //-- Utils --
  function style(props) {
      const attributeValue = Object.entries(props)
          .map(([key, value]) => `${key}: ${value}`)
          .join('; ');
      return `style="${attributeValue}"`;
  }
  function when(condition, template) {
      return condition ? template : '';
  }
  function clamp(value, min, max) {
      if (value < min) {
          return min;
      }
      if (value > max) {
          return max;
      }
      return value;
  }
  //-- Rendering --
  function typeColor(type) {
      switch (type) {
          case MoveType.Dodge: return '#080';
          case MoveType.Throw: return '#000';
          case MoveType.Strike:
              return '#f33';
          case MoveType.Projectile:
              return '#f90';
          case MoveType.BlockLow:
          case MoveType.BlockHigh:
              return '#00f';
      }
  }
  function typeClass(type) {
      switch (type) {
          case MoveType.BlockLow:
          case MoveType.BlockHigh:
              return 'block';
          case MoveType.Projectile:
              return 'projectile';
          default: return '';
      }
  }
  function toggleClass(enabled) {
      return enabled ? 'on' : 'off';
  }
  function heightStyle(height) {
      switch (height) {
          case StrikeHeight.Low: return { top: '55%' };
          case StrikeHeight.Mid: return { display: 'none' };
          case StrikeHeight.High: return { top: '25%' };
      }
  }
  function renderMove(choice) {
      const { type, damage, firstDamage, blockDamage, speed, adjust, always, height, level, description, unsafe, knockdown, edge, recur, lockdown, drawOnBlock, backstep, } = choice;
      const hasGap = type === MoveType.BlockLow || type === MoveType.BlockHigh;
      const gapPosition = type === MoveType.BlockHigh ? '50%' : '0';
      const reversal = speed > 10;
      const speedStyle = reversal ? {
          background: '#333',
          color: 'palegoldenrod',
          'border-color': 'darkgoldenrod',
      } : {
          background: 'palegoldenrod',
          color: 'black',
          'border-color': 'black',
      };
      const levelText = Array(level).fill('I').join('');
      const flags = [];
      if (unsafe) {
          flags.push(`/!\\`);
      }
      if (knockdown) {
          flags.push(`KD`);
      }
      if (edge) {
          flags.push(`(+)`);
      }
      if (recur) {
          flags.push(`RECUR`);
      }
      if (lockdown) {
          flags.push(`LOCK`);
      }
      if (drawOnBlock) {
          flags.push(`DRAW`);
      }
      if (backstep) {
          flags.push(`STEP`);
      }
      return `
        <div class="damage ${typeClass(type)}" style="background: ${typeColor(type)}">
            ${!damage ? '' : damage}
            ${!firstDamage ? '' : `(${firstDamage})`}
            ${!hasGap ? '' : `
                <div class="blockGap" ${style({ top: gapPosition })}></div>
            `}
        </div>
        <div class="description"> ${description} </div>
        <div class="flags"> ${flags.join('<br> ')} </div>
        <div class="height" ${style(heightStyle(height))}></div>

        ${when(level, `<div class="level"> ${levelText} </div>`)}
        ${when(speed, `<div class="speed" ${style(speedStyle)}> ${speed} </div>`)}
        ${when(blockDamage, `<div class="blockDamage"> ${blockDamage} </div>`)}
        ${when(adjust, `<div class="adjust"> ${adjust}${always ? '!' : ''} </div>`)}
    `;
  }
  function getChoiceRow(bot) {
      // Default choice
      const rowIndex = Math.floor((handSize - 5) / 2);
      let row = bot.normal[rowIndex];
      // Mode-specific overrides
      if (desperate) {
          row = applyOverride(row, bot.desperate);
      }
      if (mode === 'knockdown') {
          row = applyOverride(row, bot.knockdown);
      }
      return row;
  }
  function getChoice(bot) {
      const row = getChoiceRow(bot);
      if (hitback) {
          return row.hitback;
      }
      return row.choices[choiceIndex];
  }
  function renderContent() {
      if (showPicker) {
          return renderPicker();
      }
      else {
          return renderBot(chosenBot);
      }
  }
  function renderBot(bot) {
      if (!bot) {
          return `
            <div class="header">
                <button class="fixed" data-action="picker">Change</button>
            </div>
            <h1>⚠ Work in progress! ⚠</div>
        `;
      }
      const choice = getChoice(bot);
      const isKnockdown = mode == 'knockdown';
      const choiceText = hitback ? '*' : choiceIndex + 1;
      return `
        <div class="screen main">
            <div class="header">
                <span>[${handSize}] / ${choiceText}</span>
                <span> ${(bot.name)}</span>
                <button class="fixed" data-action="picker">Change</button>
            </div>
            <div class="move"> ${renderMove(choice)} </div>
            <div class="toggles">
                <button data-action="desperate" class="${toggleClass(desperate)}"> Desperation </button>
                <button data-action="knockdown" class="${toggleClass(isKnockdown)}"> Knockdown </button>
                <button data-action="hitback" class="${toggleClass(hitback)}"> Hitback </button>
            </div>
            <div class="controls">
                <button data-action="left"> &lt; </button>
                <button data-action="right"> &gt; </button>
                
                <button class="large" data-action="roll"> ROLL </button>
                
                <button data-action="down"> - </button>
                <button data-action="up"> + </button>
            </div>
        </div>
    `;
  }
  function renderPicker() {
      return `
        <div class="screen picker">
            <button data-action="pick" data-char="M1">(1) Glass Monk</button>
            <button data-action="pick" data-char="M2">(2) ⚠ Fox Primus</button>
            <button data-action="pick" data-char="M3">(3) ⚠ Colossus</button>
            <button data-action="pick" data-char="M4">(4) ⚠ Twilight Baron</button>
            <button data-action="pick" data-char="M5">(5) ⚠ Dragonborn Centurion</button>

            <button data-action="pick" data-char="F1">(1) ⚠ Soothing Monk</button>
            <button data-action="pick" data-char="F2">(2) Whitestar Grappler</button>
            <button data-action="pick" data-char="F3">(3) ⚠ Ancient Hero</button>
            <button data-action="pick" data-char="F4">(4) ⚠ Jandra, the Negator</button>
            <button data-action="pick" data-char="F5">(5) ⚠ Dragonborn Firebat</button>
        </div>
    `;
  }
  function main() {
      const html = document.documentElement;
      const container = document.querySelector('#main');
      const KEY_HANDLERS = {
          "ArrowLeft": choiceLeft,
          "ArrowRight": choiceRight,
          "ArrowUp": handsizeDown,
          "ArrowDown": handsizeUp,
          "r": choiceRandom,
          "k": toggleKnockdown,
          "h": toggleHitback,
          "d": toggleDesperate,
      };
      document.addEventListener('keydown', (e) => {
          const handler = KEY_HANDLERS[e.key];
          if (handler) {
              handler();
              render();
          }
      });
      const ACTION_HANDLERS = {
          roll: choiceRandom,
          left: choiceLeft,
          right: choiceRight,
          up: handsizeUp,
          down: handsizeDown,
          // Toggles
          knockdown: toggleKnockdown,
          hitback: toggleHitback,
          desperate: toggleDesperate,
          // Character picker
          picker: displayPicker,
          pick: changeCharacter,
      };
      html.addEventListener('click', e => {
          const target = e.target;
          if (target instanceof HTMLButtonElement) {
              const handler = ACTION_HANDLERS['' + target.dataset.action];
              if (handler) {
                  handler(target.dataset);
                  render();
              }
          }
      });
      function render() {
          container.innerHTML = renderContent();
      }
      // Rerender with initial state
      load();
      render();
  }
  document.addEventListener('DOMContentLoaded', main);

})();

        </script>
    
</body>
</html>